#!/usr/bin/env python

"""
Produce a formatted report from sls hosts.
"""

import json
import logging
import pprint
import socket
import time
import warnings

from collections import OrderedDict
from optparse import OptionParser

import requests
import IPy

from sls_client.find_host_info import get_host_info_json

ACTIVE_HOSTS = 'http://ps-west.es.net/lookup/activehosts.json'


class SlsReportException(Exception):
    """Custom SlsReport exception"""
    def __init__(self, value):
        # pylint: disable=super-init-not-called
        self.value = value

    def __str__(self):
        return repr(self.value)


class SlsReportWarning(Warning):
    """Custom SlsReport warning"""
    pass


def setup_log(log_path=None):
    """
    Usage:
    _log('main.start', 'happy simple log event')
    _log('launch', 'more={0}, complex={1} log=event'.format(100, 200))
    """
    # pylint: disable=redefined-variable-type
    logger = logging.getLogger("sls_report")
    if not log_path:
        handle = logging.StreamHandler()
    else:
        # it's on you to make sure log_path is valid.
        logfile = '{0}/sls_report.log'.format(log_path)
        handle = logging.FileHandler(logfile)
    handle.setFormatter(logging.Formatter('ts=%(asctime)s %(message)s'))
    logger.addHandler(handle)
    logger.setLevel(logging.INFO)
    return logger

log = setup_log()  # pylint: disable=invalid-name


def _log(event, msg):
    log.info('event=%s id=%s %s', event, int(time.time()), msg)


class SlsReportBase(object):
    """
    Base class for other report classes.
    """
    def __init__(self, options, logger):
        self._options = options
        self._log = logger
        self._pp = pprint.PrettyPrinter(indent=4)

    def pretty_verbose(self, obj):
        """
        Pretty print data structures if --verbose flag is on.
        """
        if self._options.verbose:
            self._pp.pprint(obj)

    @staticmethod
    def warn(msg):
        """raise a custom warning."""
        warnings.warn(msg, SlsReportWarning, stacklevel=2)


class SlsHostList(SlsReportBase):
    """
    Query the activehost node, then the lookup hosts to generate a list
    of perfSONAR hosts.

    The host_count attribute/property is used because a lookup host might
    report on a host, but not give a valid hostname. So just using
    len(self._hosts) won't give an accurate count.
    """
    def __init__(self, options, logger):
        super(SlsHostList, self).__init__(options, logger)

        self._hosts = list()
        self._host_count = 0

        self._lookup_hosts = list()

        # Get the main lookup host list or it's a no go

        self._log('SlsHostList.init.run', 'fetching activehost list')

        try:
            r = requests.get(options.active_source)
        except requests.exceptions.ConnectionError as ex:
            raise SlsReportException('activehost lookup connection error: {ex}'.format(ex=str(ex)))

        if not r.status_code == 200:
            raise SlsReportException('Request to {host} failed: status:{code} {msg}'.format(
                host=options.active_source,
                code=r.status_code,
                msg=r.content
                ))

        host_source = json.loads(r.content)

        for i in host_source.get('hosts'):
            self._lookup_hosts.append(i.get('locator'))

        self.pretty_verbose(self._lookup_hosts)

        self._log('SlsHostList.init.end',
                  'got {count} lookup hosts'.format(count=len(self._lookup_hosts)))

    def generate_host_list(self):
        """
        Query the lookup hosts and generate a list of hostnames and also
        a count of the hosts that were reported.

        force_host can be used to pass in a specific host and short circuit
        the lookups. This is to speed develoment up.
        """
        if self._options.host:
            self._log('generate_host_list.force',
                      'forcing host list: {f}'.format(f=self._options.host))
            self._hosts = [self._options.host]
            return

        for look in self._lookup_hosts:
            self._log('generate_host_list.run', 'querying {host}'.format(host=look))
            fail_msg = 'query to {host} failed'.format(host=look)
            try:
                r = requests.get(look, params=dict(type='host'))
            except requests.exceptions.ConnectionError as ex:
                self.warn('Unable to connect to {host} : {ex} - skipping'.format(
                    host=look, ex=str(ex)))
                self._log('generate_host_list.error', fail_msg)

            if not r.status_code == 200:
                msg = 'non http 200 return code: {code} {msg}'.format(
                    code=r.status_code, msg=r.content)
                self.warn(msg)
                self._log('generate_host_list.error', fail_msg)

            payload = json.loads(r.content)

            # self.pretty_verbose(payload)

            for i in payload:
                host = self._extract_hostname(i.get('host-name'))

                if host:
                    # got a hostname, stash it and increment
                    self._hosts.append(host)
                    self._host_count += 1
                elif i.get('type', None) and i.get('uri', None):
                    # still worth counting
                    self._host_count += 1

            if self._options.single:
                self._log('generate_host_list.break', 'got --single flag - breaking')
                break

        self.pretty_verbose(self._hosts)
        self._log('generate_host_list.end', '{num} hosts found'.format(num=self._host_count))

    @staticmethod
    def _extract_hostname(hlist):
        """Get the hostname from the lookup service payload. The host-name
        element will generally be a list with a single unicode element.
        Sometimes there will be more than one element, and sometimes only
        empty strings. Find the first valid string and return."""

        host_name = None

        if isinstance(hlist, list):
            for i in hlist:
                if i and isinstance(i, unicode):
                    host_name = i
                    break

        return host_name

    @property
    def hosts(self):
        """hosts property"""
        return self._hosts

    @property
    def host_count(self):
        """host_count property"""
        return self._host_count


class SlsStatCapsule(object):
    """
    Encapsulation class and accessors manage the statistics
    from SlsStatstics.
    """
    def __init__(self):
        self._host_count = 0
        self._mtu = dict()
        self._speed = dict()
        self._iface_type = dict()
        self._iface_pub = dict()

        self._pp = pprint.PrettyPrinter(indent=4)

    def tick_host_count(self):
        """increment host count."""
        self._host_count += 1

    # stats to count numbers of things.

    def _counter(self, dname, val):
        """Interface to the underlying dicts meant to count instances of things."""
        cdict = getattr(self, dname)
        if val not in cdict:
            cdict[val] = 0
        cdict[val] += 1

    def mtu(self, mtu):
        """store mtu values."""
        for val in mtu:
            self._counter('_mtu', val)

    def nic_speed(self, speed):
        """store nic speed values."""

        xlate = {
            '40000000000': u'40Gbps',
            '20000000000': u'20Gbps',
            '10000000000': u'10Gbps',
            '1000000000': u'1Gbps',
            '2000000000': u'2Gbps',
            '100000000': u'100Mbps',
            '10000000': u'10Mbps',
            '0': u'undefined',
        }

        for val in speed:
            self._counter('_speed', xlate.get(val))

    def iface_summary(self, addresses):
        """store the nature of the addresses on the interfaces."""
        for addy in addresses:
            try:
                ip = IPy.IP(addy)
            except ValueError:
                # fqdn -> ip
                ip = IPy.IP(socket.gethostbyname(addy))

            self._counter('_iface_type', ip.version())

            if ip.iptype() == 'PRIVATE':
                self._counter('_iface_pub', 'private')
            else:
                self._counter('_iface_pub', 'public')

    # formatting, etc.

    def _dict_to_stat(self, dname):
        """convert a 'counter' dict to a sorted dict of percentages."""
        sdict = getattr(self, dname)
        total = sum(sdict.values())

        stat_dict = OrderedDict()

        for order in sorted(sdict.keys()):

            val = '{0} %'.format(round((sdict.get(order) / total) * 100, 3))
            stat_dict.update({order: (sdict.get(order), val,)})

        return stat_dict

    def to_dict(self):
        """Return a sorted dict of the statistics."""
        doc = OrderedDict(
            [
                ('mtu summary', self._dict_to_stat('_mtu')),
            ]
        )

        return doc

    def __str__(self):
        return json.dumps(self.to_dict(), indent=4)


class SlsStatistics(SlsReportBase):
    """
    Take an SlsHostList object and use the sls_client library to get
    detailed information about the hosts.

    Then used to generate reports.
    """
    def __init__(self, sls_hosts, options, logger):
        super(SlsStatistics, self).__init__(options, logger)

        self._sls_hosts = sls_hosts

        self._query_count = 0
        self._good_record = False

        self._capsule = SlsStatCapsule()

    def query_hosts(self):
        """
        Use the sls_client to lookup information on the hosts
        in the SlsHostList.
        """

        self._log('query_hosts.begin', 'start')

        for host in self._sls_hosts.hosts:

            self._log('query_hosts.run', 'querying: {host}'.format(host=host))

            result = json.loads(get_host_info_json(host))

            """
            in main:

            host-os-name | host-os-version | host-os-kernel[0] (list)
            pshost-toolkitversion
            architecture from end of kernel string

            Domains???
            Can use https://github.com/john-kurkowski/tldextract ?
            search-query element in "outer" payload has the hostname
            """

            for res_host in result.get('host', []):
                self.pretty_verbose(res_host)

                if self._good_record is False and len(res_host.get('host-net-interfaces', [])) > 0:
                    self._log('query_hosts.run', 'found first good record')
                    self._good_record = True

                self._capsule.tick_host_count()

                for iface in res_host.get('host-net-interfaces', []):
                    # get stats about the interface
                    self._capsule.mtu(iface.get('interface-mtu'))
                    self._capsule.nic_speed(iface.get('interface-capacity'))
                    self._capsule.iface_summary(iface.get('interface-addresses'))

            self._pp.pprint(self._capsule.__dict__)
            print self._capsule

            if self._options.single and self._good_record:
                self._log('query_hosts.break', '--single flag and a good record - breaking')
                break

        self._log('query_hosts.end', 'client lookup on {num} hosts'.format(num=self._query_count))


def main():
    """Execute the report."""
    usage = '%prog [ -h ACTIVE_HOSTS | -v ]'
    parser = OptionParser(usage=usage)
    parser.add_option('-a', '--active-hosts', metavar='ACTIVE_SOURCE',
                      type='string', dest='active_source', default=ACTIVE_HOSTS,
                      help='Source of the seed active hosts file (default: %default) .')
    parser.add_option('-s', '--single',
                      dest='single', action='store_true', default=False,
                      help='Query a single host and then break. Primarily for development.')
    parser.add_option('-H', '--host', metavar='HOST',
                      type='string', dest='host', default=None,
                      help='Force host list to use a single host. Primarily for development.')
    parser.add_option('-v', '--verbose',
                      dest='verbose', action='store_true', default=False,
                      help='Verbose output.')
    options, _ = parser.parse_args()

    try:
        lookup_hosts = SlsHostList(options, _log)
    except SlsReportException as ex:
        print str(ex)
        return -1

    lookup_hosts.generate_host_list()

    # get detailed information on the hosts the host list
    report = SlsStatistics(lookup_hosts, options, _log)
    report.query_hosts()

if __name__ == '__main__':
    main()
