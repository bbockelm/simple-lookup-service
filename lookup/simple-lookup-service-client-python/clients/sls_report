#!/usr/bin/env python

"""
Produce a formatted report from sls hosts.
"""

import json
import logging
import pprint
import socket
import time
import warnings

from collections import OrderedDict
from optparse import OptionParser

import IPy
import requests
import tldextract

from sls_client.find_host_info import get_host_info_json

ACTIVE_HOSTS = 'http://ps-west.es.net/lookup/activehosts.json'


class SlsReportException(Exception):
    """Custom SlsReport exception"""
    def __init__(self, value):
        # pylint: disable=super-init-not-called
        self.value = value

    def __str__(self):
        return repr(self.value)


class SlsReportWarning(Warning):
    """Custom SlsReport warning"""
    pass


def setup_log(log_path=None):
    """
    Usage:
    _log('main.start', 'happy simple log event')
    _log('launch', 'more={0}, complex={1} log=event'.format(100, 200))
    """
    # pylint: disable=redefined-variable-type
    logger = logging.getLogger("sls_report")
    if not log_path:
        handle = logging.StreamHandler()
    else:
        # it's on you to make sure log_path is valid.
        logfile = '{0}/sls_report.log'.format(log_path)
        handle = logging.FileHandler(logfile)
    handle.setFormatter(logging.Formatter('ts=%(asctime)s %(message)s'))
    logger.addHandler(handle)
    logger.setLevel(logging.INFO)
    return logger

log = setup_log()  # pylint: disable=invalid-name


def _log(event, msg):
    log.info('event=%s id=%s %s', event, int(time.time()), msg)


class SlsReportBase(object):
    """
    Base class for other report classes.
    """
    def __init__(self, options, logger):
        self._options = options
        self._log = logger
        self._pp = pprint.PrettyPrinter(indent=4)

    def pretty_verbose(self, obj):
        """
        Pretty print data structures if --verbose flag is on.
        """
        if self._options.verbose:
            self._pp.pprint(obj)

    @staticmethod
    def warn(msg):
        """raise a custom warning."""
        warnings.warn(msg, SlsReportWarning, stacklevel=2)


class SlsHostList(SlsReportBase):
    """
    Query the activehost node, then the lookup hosts to generate a list
    of perfSONAR hosts.

    The host_count attribute/property is used because a lookup host might
    report on a host, but not give a valid hostname. So just using
    len(self._hosts) won't give an accurate count.
    """
    def __init__(self, options, logger):
        super(SlsHostList, self).__init__(options, logger)

        self._hosts = list()
        self._host_count = 0

        self._lookup_hosts = list()

        # Get the main lookup host list or it's a no go

        self._log('SlsHostList.init.run', 'fetching activehost list')

        try:
            r = requests.get(options.active_source)
        except requests.exceptions.ConnectionError as ex:
            raise SlsReportException('activehost lookup connection error: {ex}'.format(ex=str(ex)))

        if not r.status_code == 200:
            raise SlsReportException('Request to {host} failed: status:{code} {msg}'.format(
                host=options.active_source,
                code=r.status_code,
                msg=r.content
                ))

        host_source = json.loads(r.content)

        for i in host_source.get('hosts'):
            self._lookup_hosts.append(i.get('locator'))

        self.pretty_verbose(self._lookup_hosts)

        self._log('SlsHostList.init.end',
                  'got {count} lookup hosts'.format(count=len(self._lookup_hosts)))

    def generate_host_list(self):
        """
        Query the lookup hosts and generate a list of hostnames and also
        a count of the hosts that were reported.

        force_host can be used to pass in a specific host and short circuit
        the lookups. This is to speed develoment up.
        """
        if self._options.host:
            self._log('generate_host_list.force',
                      'forcing host list: {f}'.format(f=self._options.host))
            self._hosts = [self._options.host]
            return

        for look in self._lookup_hosts:
            self._log('generate_host_list.run', 'querying {host}'.format(host=look))
            fail_msg = 'query to {host} failed'.format(host=look)
            try:
                r = requests.get(look, params=dict(type='host'))
            except requests.exceptions.ConnectionError as ex:
                self.warn('Unable to connect to {host} : {ex} - skipping'.format(
                    host=look, ex=str(ex)))
                self._log('generate_host_list.error', fail_msg)

            if not r.status_code == 200:
                msg = 'non http 200 return code: {code} {msg}'.format(
                    code=r.status_code, msg=r.content)
                self.warn(msg)
                self._log('generate_host_list.error', fail_msg)

            payload = json.loads(r.content)

            # self.pretty_verbose(payload)

            for i in payload:
                host = self._extract_hostname(i.get('host-name'))

                if host:
                    # got a hostname, stash it and increment
                    self._hosts.append(host)
                    self._host_count += 1
                elif i.get('type', None) and i.get('uri', None):
                    # still worth counting
                    self._host_count += 1

            if self._options.single:
                self._log('generate_host_list.break', 'got --single flag - breaking')
                break

        self.pretty_verbose(self._hosts)
        self._log('generate_host_list.end', '{num} hosts found'.format(num=self._host_count))

    @staticmethod
    def _extract_hostname(hlist):
        """Get the hostname from the lookup service payload. The host-name
        element will generally be a list with a single unicode element.
        Sometimes there will be more than one element, and sometimes only
        empty strings. Find the first valid string and return."""

        host_name = None

        if isinstance(hlist, list):
            for i in hlist:
                if i and isinstance(i, unicode):
                    host_name = i
                    break

        return host_name

    @property
    def hosts(self):
        """hosts property"""
        return self._hosts

    @property
    def host_count(self):
        """host_count property"""
        return self._host_count


class SlsStatCapsule(object):  # pylint: disable=too-many-instance-attributes
    """
    Encapsulation class and accessors manage the statistics
    from SlsStatstics.
    """
    def __init__(self):
        self._host_count = 0
        self._counter_stats = dict()

        self._pp = pprint.PrettyPrinter(indent=4)

    def tick_host_count(self):
        """increment host count."""
        self._host_count += 1

    # stats to count numbers of things.

    def _counter(self, dname, val):
        """Interface to the underlying dicts meant to count instances of things."""

        if dname not in self._counter_stats:
            self._counter_stats[dname] = dict()

        if val not in self._counter_stats.get(dname):
            self._counter_stats[dname][val] = 0

        self._counter_stats[dname][val] += 1

    def mtu(self, mtu):
        """store mtu values."""
        if mtu:
            for val in mtu:
                self._counter('mtu', val)

    def nic_speed(self, speed):
        """store nic speed values."""

        xlate = {
            '40000000000': u'40 Gbps',
            '20000000000': u'20 Gbps',
            '10000000000': u'10 Gbps',
            '1000000000': u'1 Gbps',
            '2000000000': u'2 Gbps',
            '100000000': u'100 Mbps',
            '10000000': u'10 Mbps',
            '0': u'undefined',
        }

        if speed:
            for val in speed:
                self._counter('speed', xlate.get(val))

    def iface_summary(self, addresses):
        """store the nature of the addresses on the interfaces,
        ipv4/6, public/private, domains, etc."""
        if addresses:
            for addy in addresses:
                try:
                    ip = IPy.IP(addy)
                except ValueError:
                    # fqdn -> ip
                    ip = IPy.IP(socket.gethostbyname(addy))

                self._counter('iface_type', ip.version())

                if ip.iptype() == 'PRIVATE':
                    self._counter('iface_pub', 'private')
                else:
                    self._counter('iface_pub', 'public')

                try:
                    fqdn = socket.gethostbyaddr(ip.strNormal())[0]
                    extract = tldextract.extract(fqdn)

                    self._counter('domains', extract.registered_domain)
                except socket.herror:
                    # couldn't resolve, so skip it
                    pass

    def ps_toolkit_version(self, version):
        """store the ps toolkit version."""
        if version:
            for ver in version:
                self._counter('ps_version', ver)

    # formatting, etc.

    def _dict_to_stats(self, dname):
        """convert a 'counter' sub-dict to a sorted dict of percentages."""
        sdict = self._counter_stats.get(dname, {})
        total = sum(sdict.values())

        stat_dict = OrderedDict()

        for order in sorted(sdict.keys()):

            val = round(
                (float(sdict.get(order)) / total) * 100,
                2
            )

            stat_dict.update({order: (sdict.get(order), val,)})

        return stat_dict

    def to_dict(self):
        """Return a sorted dict of the statistics."""
        doc = OrderedDict(
            [
                ('domains', self._dict_to_stats('domains')),
                ('iface_version', self._dict_to_stats('iface_type')),
                ('public_private', self._dict_to_stats('iface_pub')),
                ('mtu_summary', self._dict_to_stats('mtu')),
                ('iface_speed', self._dict_to_stats('speed')),
                ('ps_version', self._dict_to_stats('ps_version')),
            ]
        )

        return doc

    @property
    def host_count(self):
        """get the host count"""
        return self._host_count

    def __str__(self):
        """str repr"""
        return json.dumps(self.to_dict(), indent=4)


class SlsStatistics(SlsReportBase):
    """
    Take an SlsHostList object and use the sls_client library to get
    detailed information about the hosts.

    Then used to generate reports.
    """
    def __init__(self, sls_hosts, options, logger):
        super(SlsStatistics, self).__init__(options, logger)

        self._sls_hosts = sls_hosts

        self._query_count = 0
        self._good_record = False

        self._capsule = SlsStatCapsule()

    def query_hosts(self):
        """
        Use the sls_client to lookup information on the hosts
        in the SlsHostList.
        """

        self._log('query_hosts.begin', 'start')

        for host in self._sls_hosts.hosts:

            self._log('query_hosts.run', 'querying: {host}'.format(host=host))

            result = json.loads(get_host_info_json(host))

            """
            in main:

            host-os-name | host-os-version | host-os-kernel[0] (list)
            architecture from end of kernel string

            """

            for res_host in result.get('host', []):
                self.pretty_verbose(res_host)

                # keep track of the first time we see an entry with interface
                # information for development/--single.
                if self._good_record is False and len(res_host.get('host-net-interfaces', [])) > 0:
                    self._log('query_hosts.run', 'found first good record')
                    self._good_record = True

                self._capsule.tick_host_count()

                self._capsule.ps_toolkit_version(res_host.get('pshost-toolkitversion'))

                for iface in res_host.get('host-net-interfaces', []):
                    if not isinstance(iface, dict):
                        continue
                    self._capsule.mtu(iface.get('interface-mtu'))
                    self._capsule.nic_speed(iface.get('interface-capacity'))
                    self._capsule.iface_summary(iface.get('interface-addresses'))

            self._pp.pprint(self._capsule.__dict__)
            print self._capsule

            if self._options.single and self._good_record:
                self._log('query_hosts.break', '--single flag and a good record - breaking')
                break

        self._log('query_hosts.end',
                  'client lookup on {num} hosts'.format(num=self._capsule.host_count))


def main():
    """Execute the report."""
    usage = '%prog [ -h ACTIVE_HOSTS | -v ]'
    parser = OptionParser(usage=usage)
    parser.add_option('-a', '--active-hosts', metavar='ACTIVE_SOURCE',
                      type='string', dest='active_source', default=ACTIVE_HOSTS,
                      help='Source of the seed active hosts file (default: %default) .')
    parser.add_option('-s', '--single',
                      dest='single', action='store_true', default=False,
                      help='Query a single host and then break. Primarily for development.')
    parser.add_option('-H', '--host', metavar='HOST',
                      type='string', dest='host', default=None,
                      help='Force host list to use a single host. Primarily for development.')
    parser.add_option('-v', '--verbose',
                      dest='verbose', action='store_true', default=False,
                      help='Verbose output.')
    options, _ = parser.parse_args()

    try:
        lookup_hosts = SlsHostList(options, _log)
    except SlsReportException as ex:
        print str(ex)
        return -1

    lookup_hosts.generate_host_list()

    # get detailed information on the hosts the host list
    report = SlsStatistics(lookup_hosts, options, _log)
    report.query_hosts()

if __name__ == '__main__':
    main()
